import fs from "node:fs";
import path from "node:path";

const REPO_ROOT = process.cwd();
const TASKS_DIR = path.join(REPO_ROOT, "docs", "tasks");
const OUTPUT_PATH = path.join(TASKS_DIR, "dogfood-status.md");

function formatDateYYYYMMDD(date) {
  const year = String(date.getFullYear());
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function featureSortKey(featureId) {
  // Examples:
  // "00" -> 0
  // "00.5" -> 0.5
  // "12" -> 12
  const asNumber = Number(featureId);
  if (Number.isFinite(asNumber)) return asNumber;
  return Number.POSITIVE_INFINITY;
}

function parseDogfoodChecklistLines(lines) {
  const startIdx = lines.findIndex((l) => l.trim().startsWith("## Dogfooding Checklist"));
  if (startIdx === -1) return null;

  const items = [];
  for (let i = startIdx + 1; i < lines.length; i += 1) {
    const line = lines[i];
    if (line.trim().startsWith("## ")) break;
    const match = line.match(/^\s*-\s+\[(?<checked>[ xX])\]\s+(?<text>.+?)\s*$/);
    if (!match?.groups) continue;
    items.push({
      checked: match.groups.checked.toLowerCase() === "x",
      text: match.groups.text,
    });
  }

  return { items };
}

function parseFeatureHeader(lines) {
  const h1 = lines.find((l) => l.trim().startsWith("# "));
  if (!h1) return null;
  return h1.trim();
}

function collectFeatureFiles() {
  const entries = fs.readdirSync(TASKS_DIR, { withFileTypes: true });
  return entries
    .filter((e) => e.isFile())
    .map((e) => e.name)
    .filter((name) => name.startsWith("feature-") && name.endsWith(".md"))
    .map((name) => path.join(TASKS_DIR, name));
}

function extractFeatureIdFromFilename(filename) {
  const base = path.basename(filename);
  // "feature-00.5-prototype-polish.md" -> "00.5"
  // "feature-12-code-explorer.md" -> "12"
  const match = base.match(/^feature-(?<id>[^-]+)-/);
  return match?.groups?.id ?? null;
}

function generateStatusMarkdown({ generatedDate, features }) {
  const dateStr = formatDateYYYYMMDD(generatedDate);

  const lines = [];
  lines.push("# Dogfood Status (Generated)");
  lines.push("");
  lines.push(`Updated: ${dateStr}`);
  lines.push("");
  lines.push("Generated by: `node scripts/update-dogfood-status.mjs`");
  lines.push("");
  lines.push("Rules:");
  lines.push("- This file is generated from each feature file's `## Dogfooding Checklist` section.");
  lines.push("- Check/uncheck items in the feature files, then re-run the generator.");
  lines.push("");

  if (features.length === 0) {
    lines.push("_No feature dogfooding checklists found._");
    lines.push("");
    return lines.join("\n");
  }

  lines.push("## Summary");
  lines.push("");

  for (const f of features) {
    const status = f.total === 0 ? "no checklist" : f.checked === f.total ? "pass" : "in progress";
    lines.push(`- ${f.header}: ${f.checked}/${f.total} (${status})`);
    lines.push(`- File: \`${path.relative(REPO_ROOT, f.file)}\``);
    if (f.pending.length > 0) {
      lines.push("- Pending:");
      for (const p of f.pending.slice(0, 10)) {
        // Keep it flat: prefix with "  - " would be a nested bullet; instead inline.
        lines.push(`- [ ] ${p}`);
      }
      if (f.pending.length > 10) lines.push(`- ... plus ${f.pending.length - 10} more`);
    }
    lines.push("");
  }

  lines.push("## How To Update");
  lines.push("");
  lines.push("- Run: `node scripts/update-dogfood-status.mjs`");
  lines.push("");

  return lines.join("\n");
}

function main() {
  const featureFiles = collectFeatureFiles();

  const features = [];
  for (const file of featureFiles) {
    const featureId = extractFeatureIdFromFilename(file);
    if (!featureId) continue;

    const raw = fs.readFileSync(file, "utf8");
    const lines = raw.split(/\r?\n/);

    const header = parseFeatureHeader(lines);
    const checklist = parseDogfoodChecklistLines(lines);
    if (!header || !checklist) continue;

    const total = checklist.items.length;
    const checked = checklist.items.filter((i) => i.checked).length;
    const pending = checklist.items.filter((i) => !i.checked).map((i) => i.text);

    features.push({
      featureId,
      sortKey: featureSortKey(featureId),
      file,
      header,
      total,
      checked,
      pending,
    });
  }

  features.sort((a, b) => a.sortKey - b.sortKey || a.featureId.localeCompare(b.featureId));

  const md = generateStatusMarkdown({ generatedDate: new Date(), features });
  fs.writeFileSync(OUTPUT_PATH, md, "utf8");
}

main();
